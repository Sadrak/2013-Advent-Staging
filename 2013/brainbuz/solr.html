<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@maya.(none)" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#TITLE">TITLE</a></li>
  <li><a href="#OVERVIEW">OVERVIEW</a></li>
  <li><a href="#INTRODUCTION">INTRODUCTION</a>
    <ul>
      <li><a href="#Solr-Basics">Solr Basics</a></li>
      <li><a href="#Alternatives-To-Solr">Alternatives To Solr</a></li>
      <li><a href="#Perl-Modules">Perl Modules</a></li>
    </ul>
  </li>
  <li><a href="#Preparing-the-Environment">Preparing the Environment</a></li>
  <li><a href="#You-need-to-upgrade-to-at-least-Catalyst-5.90051">You need to upgrade to at least Catalyst 5.90051</a></li>
  <li><a href="#Catalyst::Model::WebService::Solr">Catalyst::Model::WebService::Solr</a></li>
  <li><a href="#For-More-Information">For More Information</a></li>
  <li><a href="#Summary">Summary</a></li>
  <li><a href="#Author">Author</a></li>
</ul>

<h1 id="TITLE">TITLE</h1>

<p>An Example Catalyst Plugin - Catalyst::Plugin::RunRequest</p>

<h1 id="OVERVIEW">OVERVIEW</h1>

<p>Using <a href="http://lucene.apache.org/Solr/">Solr</a>, a Search Server from <a href="http://lucene.apache.org">Apache&#39;s Lucene Project</a> as a <b>Catalyst Model</b>.</p>

<h1 id="INTRODUCTION">INTRODUCTION</h1>

<p>Compared to conventional database search (and the full text query extensions found in most modern SQL implementations), a Search Server is going to provide better performance and search features. Since Solr is writeable as well as readable it can be used as a NoSQL datastore, with all the caveats that accompany something which is certainly not ACID compliant.</p>

<h2 id="Solr-Basics">Solr Basics</h2>

<p>Solr is a java servelet, implementing a web based interface to Lucene. Requests to Solr are made via http requests. Request data may be sent in either post or get values. Data is returned in json but Solr will also return data in xml or csv formats. Similarly posts of data to Solr may be in any of these formats. Lucene provides indexing and search technology, as well as spellchecking, hit highlighting and advanced analysis/tokenization capabilities. The Data Import Handler will allow you to import from lots of other sources rather than needing to post it all through web requests. Once up and going it gives you a lot of possibilities for finding documents.</p>

<h2 id="Alternatives-To-Solr">Alternatives To Solr</h2>



<p>The most obvious alternative to Solr is direct implementation of Lucene. Since the purpose of Solr is to provide a more useable interface to Lucene in the first place, this does not seem like a good way to get started. An Alternative to Solr that is also built on Lucene is <a href="http://www.elasticsearch.org">ElasticSearch</a>. At this time there is far more written about Solr and I did not experiment with ElasticSearch. There is an official Elasticsearch module on CPAN which seems to be under very active development. </p>
<p>The Google Search Appliance offerings are expensive and have a lot of functionality limitations, they are great for simple search collections, Google also has a cloud based search offering, which has considerably less features than the appliance. The best google alternative is to point your visitors at google.com with a site qualifier in the redirect (or any other public search engine). For a lot of developers the AWS CloudSearch service is going to be of great interest, while not free as Solr is the administrative costs will for most enterprises make it the cheaper choice vs Solr or Google Appliance, on the downside it has a far more limited feature set than Solr and does not offer the option of going under the hood as Lucene provides to Solr. If you want to look at even more options Google or DuckDuckGo (who don't seem to be trying to sell search tools at the moment) will help you find them.</p>

<h2 id="Perl-Modules">Perl Modules</h2>

<p>There are a number of Perl Modules available for Solr, the two that appear the most viable are Apache::Solr and WebService::Solr. Unfortunately, all of the modules have problems both in bugs and unimplemented features. I looked at these and some other options and my first time through none of them rated satisfactory. Initally I had the best luck with Apache::Solr but was not very satisfied with it. After reading through the source code several of the modules, I decided to work with WebService::Solr.</p>

<h1 id="Preparing-the-Environment">Preparing the Environment</h1>

<p>You will need to have a Catalyst Development Environment ready, in addition you should install WebService::Solr and optionally Catalyst::Model::WebService::Solr. You will also need to install a JVM like open JDK and then download a copy of Solr from <a href="http://lucene.apache.org/solr/downloads.html">http://lucene.apache.org/solr/downloads.html</a>. Once downloaded and extracted you will need to load the example data. Open up two terminals. To save space I&#39;ll refer you to the Solr tutorial, to speed up you use post.sh in the exampledocs folder to populate the test data, and skip ahead to querying to confirm that you have loaded the 32 documents. For the purpose of the rest of the article it will be assumed you have solr running locally with the test data loaded and answering the default port 8983 ,</p>

<pre><code> Terminal 1
 cd ..path_to../example
 java -jar start.jar
 
 Terminal 2
 cd ..path_to../example/exampledocs
 ./post.sh *.xml</code></pre>

<h1 id="You-need-to-upgrade-to-at-least-Catalyst-5.90051">You need to upgrade to at least Catalyst 5.90051</h1>

<p>Catalyst 5.90050 introduced a new configuration setting to help with unicode compatibility. If updating Catalyst isn&#39;t an option for you the workaround I was using is detailed in rtcpan bug 89288. I also strongly recommend using the latest Perl. Just about every release of Perl has some improvement to unicode handling, I used 5.18.1 when developing this tutorial with Plenv and PerlBrew there is no good reason not to.</p>

<p>Create A Project</p>

<pre><code> catalyst.pl SolrDemo
 cd SolrDemo
 ./script/solremo_create.pl view HTML TT
 </code></pre>

<p>Edit the SolrDemo.conf files</p>

<pre><code> solrserver         http://localhost:8983/solr/</code></pre>

<p>Edit the config section of lib/SolrDemo.pm</p>

<pre><code> __PACKAGE__-&gt;config(
    name =&gt; &#39;SolrDemo&#39;,
    # Disable deprecated behavior needed by old applications
    disable_component_resolution_regex_fallback =&gt; 1,
    enable_catalyst_header =&gt; 1, # Send X-Catalyst header
    encoding =&gt; &#39;utf8&#39;, # prevents wide character explosions
    &#39;View::HTML&#39; =&gt; {  #Set the location for TT files        
         INCLUDE_PATH =&gt; [ CalEvt-&gt;path_to( &#39;root&#39; ), ], },    
 );</code></pre>

<p>Create a Model and Test</p>

<pre><code> touch lib/SolrDemo/Model/Solr.pm
 touch lib/SolrDemo/Model/SolrModelSolr.pm 
 touch 
 touch t/model_solr.t
 </code></pre>

<h1 id="Catalyst::Model::WebService::Solr">Catalyst::Model::WebService::Solr</h1>

<p>The first excercise is going to use WebService::Solr::Query.</p>

<pre><code>    package SolrDemo::Controller::Thin;
    use Moose;
    use namespace::autoclean;
    use WebService::Solr::Query;

    BEGIN { extends &#39;Catalyst::Controller&#39; }

    #you wouldn&#39;t keep code like this in your project&#39;s controller it belongs in a model or external module.
    sub response2info {
        my $response = shift;
        my $raw      = $response-&gt;raw_response();
        my $pre      = &#39;&#39;;
        $pre .= &quot;\n_msg\n&quot; . $raw-&gt;{&#39;_msg&#39;};
        $pre .= &quot;\n_headers&quot;;
        my %hheaders = %{ $raw-&gt;{&#39;_headers&#39;} };
        for ( keys %hheaders ) { $pre .= &quot;\n    $_ = $hheaders{$_}&quot;; }
        $pre .= &quot;\n_request&quot;;
        my %rreq = %{ $raw-&gt;{&#39;_request&#39;} };
        for ( keys %rreq ) { $pre .= &quot;\n    $_ = $rreq{$_}&quot;; }
        $pre .= &quot;\n_content&lt;/pre&gt;\n&quot; . $raw-&gt;{&#39;_content&#39;} . &#39;&lt;pre&gt;&#39;;
        $pre .= &quot;\n_rc\n&quot; . $raw-&gt;{&#39;_rc&#39;};
        $pre .= &quot;\n_protocol\n&quot; . $raw-&gt;{&#39;_protocol&#39;};
        $pre .= &quot;\nRequest Status (via method)\n&quot; . $response-&gt;solr_status();
        my @docs = $response-&gt;docs;
        $pre .= &quot;\nDocument Count: &quot; . scalar(@docs);
        return $pre;
    }

    sub dump :Local :Args(0) {
        my ( $self, $c ) = @_;
        my $response   = $c-&gt;model(&#39;MSolr&#39;)-&gt;search(&#39;(*:*)&#39;, { rows =&gt; 10000 } );
        my @docs       = $response-&gt;docs;
        $c-&gt;log-&gt;info( &quot;\nDocument Count: &quot; . scalar(@docs) );
        my $pre = &amp;response2info($response);
        $c-&gt;response-&gt;body(&quot;&lt;pre&gt;$pre &lt;/pre&gt;&quot;);
    }

    sub select :Local :Args(0) {
        my ( $self, $c ) = @_;
    my $response   = $c-&gt;model(&#39;MSolr&#39;)-&gt;search(
            WebService::Solr::Query-&gt;new( { text =&gt; [&#39;hard drive&#39;] } ), { rows =&gt; 10000 } );        
        my $pre = &amp;response2info($response);
        $c-&gt;response-&gt;body(&quot;&lt;pre&gt;$pre &lt;/pre&gt;&quot;);
    }

    __PACKAGE__-&gt;meta-&gt;make_immutable;

    1;</code></pre>

<p>lib/SolrDemo/Model/SolrModelSolr.pm</p>

<pre><code> =head1 $SECTIONS</code></pre>

<p>As many sections as neeed to complete the article!</p>

<h1 id="For-More-Information">For More Information</h1>

<p>Where to go to learn more, for example links to CPAN distributions or source code on Github</p>

<h1 id="Summary">Summary</h1>

<p>Review of what the reader just learned.</p>

<h1 id="Author">Author</h1>

<p>Your Name &lt;your@email.com&gt; IRC nick</p>


</body>

</html>


