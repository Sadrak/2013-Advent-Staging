=head1 Title

CataylstX::Controller::PSGI - Using Plack apps inside Catalyst Controllers - Part 2

=head1 Overview

In part 1 of this article, I covered the basics of wrapping a .psgi app inside
Catalyst so we could work on adding new urls the Catalyst way, whilst still having
our legacy app working as before.

In this part I'll be covering converting parts of that legacy app into Cataylst
Models, and passing them back to the legacy app at startup

=head1 Prequisites

Read L<Part 1|http://www.catalystframework.org/calendar/2013/16> first

Note, I'll be using a copy of MyApp, called MyApp2, for the purpose of preserving
the part 1 code.

=head1 The Aim

Expand our existing app so that it's more Catalyst than legacy app, we'll do this
by replacing legacy.psgi with inline code, loading our legacy perl modules as
Catalyst Models and using the ACCEPT_CONTEXT hook to pass them to the legacy app.

=head1 The Code

We'll start by inlining our legacy app.

Change the _build_legacy_app method in Root.pm to contain the contents of the
legacy psgi.

    use Legacy::App;
    use Legacy::DB;

    sub _build_legacy_app {
        my $db = Legacy::DB->new(
            dbspec  => "legacy",
            region  => "en",
        );

        my $legacy_app = Legacy::App->new(
            db      => $db,
        );

        my $app = sub {
            my ( $env ) = @_;

            my ( $status, $body );
            if ( $env->{PATH_INFO} eq 'some/action' ) {
               ( $status, $body ) = $legacy_app->handle_request( $env->{PATH_INFO} );
            }
            elsif ( $env->{PATH_INFO} eq 'some/other/action' ) {
               ( $status, $body ) = $legacy_app->handle_request( $env->{PATH_INFO} );
            }
            elsif ( $env->{PATH_INFO} eq 'foo' ) {
               ( $status, $body ) = $legacy_app->handle_request( $env->{PATH_INFO} );
            }
            else {
                $status = 404;
                $body = 'not found';
            }

            my $res = Plack::Response->new( $status );
            $res->content_type('text/html');
            $res->body( $body );

            return $res->finalize;
        };

        $app;
    }

Looking at our legacy app, we only need a few urls, one of which has already
been over writte, so could tidy it up a bit, and seperate out the not found
action into a proper Catalyst action, if instead of using call we use mount.
The downside of this is we pass a subref to mount, so we can't use a Moose
attribute, but that's ok.

So remove the legacy app attribute, and replace it with a plain old subref, which
we can pass to mount. And whilst we're at it remove the not found handler and the
/some/other/action handler, since we've replaced that. A good thing to note with
mount is that as well as $env being passed in, $self is aswell.

    use Legacy::App;
    use Legacy::DB;

    my $app = sub {
        my $db = Legacy::DB->new(
            dbspec  => "legacy",
            region  => "en",
        );

        my $legacy_app = Legacy::App->new(
            db      => $db,
        );

        my $app = sub {
            my ( $env ) = @_;

            my ( $status, $body );
            if ( $env->{PATH_INFO} eq 'some/action' ) {
               ( $status, $body ) = $legacy_app->handle_request( $env->{PATH_INFO} );
            }
            elsif ( $env->{PATH_INFO} eq 'foo' ) {
               ( $status, $body ) = $legacy_app->handle_request( $env->{PATH_INFO} );
            }

            my $res = Plack::Response->new( $status );
            $res->content_type('text/html');
            $res->body( $body );

            return $res->finalize;
        };

        $app;
    }

    __PACKAGE__->mount( 'some/action'   => $app );
    __PACKAGE__->mount( 'foo'           => $app );

There's a lot going on there, and we can split it up further, lets do some
cleaning and add a Cataylst 404 handler, aka the default action

    use Legacy::App;
    use Legacy::DB;

    has "_db" => (
        is      => 'ro',
        builder => '_build_db',
        lazy    => 1,
    );
    sub _build_db {
        my $self = shift;
        return Legacy::DB->new(
            dbspec  => "legacy",
            region  => "en",
        );
    }

    has "_legacy_app" => (
        is      => "ro",
        builder => "_build_legacy_app",
        lazy    => 1,
    );
    sub _build_legacy_app {
        my $self = shift;
        return Legacy::App->new(
            db      => $self->_db,
        );
    }

    my $legacy_app_wrapper = sub {
        my ( $self, $env ) = @_;
        my ( $status, $body ) = $self->_legacy_app->handle_request( $env->{PATH_INFO} );

        my $res = Plack::Response->new( $status );
        $res->content_type('text/html');
        $res->body( $body );

        return $res->finalize;
    };

    __PACKAGE__->mount( 'some/action'   => $legacy_app_wrapper );
    __PACKAGE__->mount( 'foo'           => $legacy_app_wrapper );

    sub default: Local{
        my ( $self, $c ) = @_;

        $c->res->body('not found');
        $c->res->status(404);
    }

=head1 Summary

=head1 Author

Mark Ellis L<email:nobody@cpan.org>

=cut
